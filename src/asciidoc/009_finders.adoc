== Finders

Finders are part of persistence methods that are used to retrieve JPA entities from database.  In addition to static methods,
simple-jpa also supports dynamic finder.  With dynamic finder, you can find entity based on certain pattern in method name.

=== Query Methods

simple-jpa injects the following query methods:

* `executeNamedQuery(namedQuery, map, config)`
+
Execute JPA named query.

* `executeQuery(jpql, config)`
+
Execute JP QL.

* `executeNativeQuery(sql)`
+
Execute SQL.

To use named queries, you must defined them first, for example:

[source,groovy]
.Invoice.groovy
----
@NamedQuery(name='Invoice.LargeQty', query='''
	FROM Invoice inv LEFT JOIN inv.items i WHERE i.qty > :limit
''')
@DomainClass @Entity @Canonical
class Invoice {

	...

}
----

Now you can call `Invoice.LargeAmount` by using code like:

[source,groovy]
----
def result = myRepository.executeNamedQuery('Invoice.LargeQty', [limit: 500])
println "Invoices with large qty in one of their items:"
println result.collect { it.number }.join(',')
----

Named queries are parsed when application is launched.  Although they make application startup slower, they are quick to
 serve you when you need them because they're prepared.

As an alternative to named query, you can always directly call JP QL by using `executeQuery()`, for example:

[source,groovy]
----
def result = myRepository.executeQuery(
   'FROM Invoice inv LEFT JOIN inv.items i  WHERE i.qty > :limit',
   [:], [limit: 500])
----

TIP:  Don't forget that you can use `simple-jpa-console` script to launch Groovy console to try query methods described
 in this chapter.

JPA can hurt performance if your query return a very large result.  This is because JPA provider needs to translate
 every rows from native SQL query into object (entities).  Creating a lot of objects in a short time may leads to
 memory shortage in heap.  To avoid these problems, you can use `executeNativeQuery()` to execute SQL:

[source,groovy]
----

def result = myRepository.executeNativeQuery('''
   SELECT i.number, SUM(li.qty * li.price) AS total
   FROM Invoice i
   LEFT JOIN Invoice_Items li ON li.invoice_id = i.id
   GROUP BY i.number
''')
// result is an array
println result[0][0]  // print first column of first record
println result[0][1]  // print second column of first record
println result[1][0]  // print first column of second record
println result[1][1]  // print second column of second record
----

TIP: Don't use `executeNativeQuery()` if not necessary.  Your code become prone to mismatch between query and domain
classes. If you find yourself create a lot of SQL queries, you need to consider to use native SQL approach instead of JPA.

=== Dynamic Finder

Dynamic finder works by following certain pattern in method name.  For example, if you want to select all `Invoice`, you
can call the following method:

[source,groovy]
----
List result = myRepository.findAllInvoice()
println result.collect { it.number }.join(',')
----

Finder starts with `findAll` always return a `List`.  If nothing is found, it returns an empty `List`.

You can add a criteria by using adding `by` to the finder followed by property name, for example:

[source,groovy]
----
List result = myRepository.findAllInvoiceByNumber('INV02')
println result.collect { it.number }.join(',')
----

If you want to return only a single instance, drop `all` from the finder name, for example:

[source,groovy]
----
Invoice result = myRepository.findInvoiceByNumber('INV02')
println result?.number
----

The finder returns an instance of `Invoice` or `null` if nothing is found.

You can combine multiple criteria by using logical operator `and` and `or`, for example:

[source,groovy]
----
myRepository.findAllInvoiceByNumberAndDate('INV02', LocalDate.parse('2015-02-01'))
----

In the previous examples, you've searched based on equality (`eq`).  simple-jpa dynamic finders also supports different
  operators such as:

* `greaterThanEqualTo` or `ge`
* `lessThanEqualTo` or `le`
* `greaterThan` or `gt`
* `lessThan` or `lt`
* `isNotMember`
* `isNotEmpty`
* `isNotNull`
* `notEqual` or `ne`
* `isMember`
* `isEmpty`
* `isNull`
* `like`
* `notLike`
* `between`

For example, to search for all invoices created in this month, you can use the following code:

[source,groovy]
----
def dateBegin = LocalDate.now().dayOfMonth().withMinimumValue()
def dateEnd = LocalDate.now().dayOfMonth().withMaximumValue()
def result = myRepository.findAllInvoiceByDateBetween(dateBegin, dateEnd)
----

In this another example, you find products by name using `like` operator:

[source,groovy]
----
myRepository.findAllProductByNameLike('A%')
----

You can search for nested properties by using double underscore (`__`) as separator.  For example, the following
query finds all products based on supplier's location:

[source,groovy]
----
myRepository.findAllProductBySupplier__City__NameLike('a city%')
----

=== Dsl Finder

In addition to using dynamic finder, you can also perform query by using Dsl finder.  Such finder requires a closure as
 argument.  The following code show how to use Dsl Finder:

[source,groovy]
----
def dateBegin = LocalDate.now().dayOfMonth().withMinimumValue()
def dateEnd = LocalDate.now().dayOfMonth().withMaximumValue()
myRepository.findAllInvoiceByDsl {
    number eq('INV02')
    and()
    date between(dateBegin, dateEnd)
}
----

The advantage of using Dsl closure is you can build the query conditions based on certain condition.   You can also add
 any code inside the closure.  For example, the following code add query condition only if certain variables are not null:

[source,groovy]
----
def dateBeginSearch = LocalDate.now().dayOfMonth().withMinimumValue()
def dateEndSearch = LocalDate.now().dayOfMonth().withMaximumValue()
def numberSearch = null
myRepository.findAllInvoiceByDsl {
  if (numberSearch) {
    number eq(numberSearch)
  }
  if (dateBeginSearch && dateEndSearch) {
    date between(dateBeginSearch, dateEndSearch)
  }
}
----

You can also use nested properties by using double underscores (`__`) as separator, for example:

[source,groovy]
----
myRepository.findAllProductByDsl {
  supplier__name isIn(['supplier a', 'supplier b'])
  and()
  name eq('A product')
}
----

=== Named Entity Graph

Named entity graph is a new feature in JPA 2.1.  It allows you to define a flexible fetch graph without modifying your
current query.  For example, you can define named entity graph such as:

[source,groovy]
.Invoice.groovy
----
package domain

// import statements are not shown

@NamedEntityGraph(name='Invoice.Items', attributeNodes=[
  @NamedAttributeNode('items')
])
@DomainClass @Entity @Canonical(excludes='items')
class Invoice {

  @NotEmpty @Size(min=5, max=5)
  String number

  @NotNull @Type(type="org.jadira.usertype.dateandtime.joda.PersistentLocalDate")
  LocalDate date

  @ElementCollection @OrderColumn @NotEmpty
  List<LineItem> items = []

  void add(LineItem item) {
    items << item
  }

  BigDecimal total() {
    items.sum { it.total() }
  }

}
----

If you want to use named entity graph in simple-jpa finders, you should always start the name with domain class name
 followed by a period (`.`) before the actual name.  To use named entity graph, add `fetch` or `load` to dynamic finder,
 for example:

[source,groovy]
----
// items is lazy loaded.  It will trigger SQL query when code refer to it.
// result is not safe to be passed to outside transaction because
// SQL query is required to retrieve items.
def result = myRepository.findAllInvoice()

// items has been loaded.
// anotherResult is safe to be passed to outside transaction because
// items is safe to read from anywhere.
def anotherResult = myRepository.findAllInvoiceFetchItems()
----

In addition to using `fetch` in dynamic finder, you can also use named entity graph by passing them query configuration
 using `fetchGraph` or `loadGraph` as key.  See <<query-configuration>> for more information.

=== Query Configuration

Most of finder methods described so far can receive a configuration parameter in form of `Map`.  You can use the following
 values as its keys:

* `excludeSubclass`
+
The value must be a string.  Normal query returns all instances of current class and its subclasses.  For example, if `Employee`
 has three subclasses `Teacher`, `Researcher`, and `Staff`, then `findAllEmploye()` returns instances of  `Employee`, `Teacher`,
 `Researcher` and `Staff`.  If you want to return only `Teacher` and `Staff`, you can use the following code:
+
[source,groovy]
----
myRepository.findAllEmployee([excludeSubclass: 'Researcher'])
----
+
Assuming `Employee` is not an abstract class and it have instances, then you can use following code to only return instances
of `Employee`:
+
[source,groovy]
----
myRepository.findAllEmployee([excludeSubclass: '*'])
----

* `flushMode`
+
The value must be one of `FlushModeType.COMMIT` or `FlushModeType.AUTO`.  Use this key to override flush mode for current query.

* `excludeDeleted`
+
The value is a boolean (`true` or `false`).  If it is `true`, query will not return soft deleted entities. An entity is
considered as soft deleted if its `deleted` property is equals to `'Y'`.

* `orderBy`
+
The value must be a string.  Use this key to sort current query.  If you have multiple attributes to sort, separate them by comma,
 for example:
+
[source,groovy]
----
myRepository.findAllInvoice([orderBy: 'number,date'])
----
+
If you want to sort by nested property, use double underscore (`__`) as separator.

* `orderDirection`
+
The value must be one of the following string: `asc` or `desc`.  This key is used to specify the direction of order in `orderBy`.
For example, the following query will find all invoices sorted by number in ascending direction and date in descending direction:
+
[source,groovy]
----
myRepository.findAllInvoice([orderBy: 'number,date', orderDirection: 'asc,desc'])
----

* `page`
+
The value must be a number starting from `1`.  Use this key together with `pageSize` to limit query result.  Default value for
`page` is `1`.
+

* `pageSize`
+
The value must be a positive number.  Use this key to set the size for current page.  If `page` is specified but `pageSize`
 is not set, then it is assumed to be `10`.  If both `page` and `pageSize` is not specified, there will be no limit for this query.
+
For example, to retrieve only 3 first invoices, you can use the following configuration:
+
[source,groovy]
----
myRepository.findAllInvoice([pageSize:3])
----

* `allowDuplicate`
+
The value is a boolean (`true` or `false`).  Set it to `true` to never returns duplicate entities.  This configuration adds
 `SELECT DISTINCT` to current query.

* `fetchGraph`
+
This key accepts a `String` or an instance of `EntityGraph` created by using `entityManager.createEntityGraph()`.  If you
 have defined named entity graph called `Invoice.Items`, you can use it in finders like:
+
[source,groovy]
----
myRepository.findAllInvoice([fetchGraph: 'Invoice.Items'])
----
+
Or, you can also build the named entity graph in runtime such as in this sample:
+
[source,groovy]
----
myRepository.withTransaction {
    def em = getEntityManager()
    def g = em.createEntityGraph(Invoice)
    g.addAttributeNodes('items')
    findAllInvoice([fetchGraph: g])
}
----

* `loadGraph`
+
This key accepts a `String` or an instance of `EntityGraph` created by using `entityManager.createEntityGraph()`.  See
 the description of `fetchGraph` for more information.

You can also add some of the query configurations described above in `Config.groovy`.  This way the configuration is
 globally applied to all finders that can accepts it.  The following table lists all query configurations that
  can be added in `Config.groovy`:

.Query Configuration In `Config.groovy`
|===
|Name | Default Value | Description

|`griffon.simplejpa.entityManager.defaultFlushMode`
|`FlushModeType.AUTO`
|You can also change the flush mode to `FlushModeType.COMMIT` (or just `'COMMIT'`).

|`griffon.simplejpa.finders.alwaysExcludeSoftDeleted`
|`false`
|If this value is `true`, finders will not return soft deleted entities.

|`griffon.simplejpa.finders.alwaysAllowDuplicate`
|`true`
|The default value always add `SELECT DISTINCT` to the generated query.  If you don't need this feature, you can
increase performance by setting this value to `false`.
|===


