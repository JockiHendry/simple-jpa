[appendix]
== Methods

simple-jpa will inject JPA related methods to all controllers (or other artifacts configured in
+griffon.simplejpa.finders.injectInto+). These methods are always public.

=== beginTransaction()

It is not recommended to call this method directly. This is a low level method that will be called by +@Transaction+.

Use this method to start a new transaction. If resume parameter is true, it will join the previous transaction if
previous transaction is exists. If newSession parameter is true, this method will destroy previous EntityManager.

Example of low level operations using simple-jpa:

[source,groovy]
----
beginTransaction()
def em = getEntityManager()
... // perform works with em
em.close()
commitTransaction()
----

=== commitTransaction()

It is not recommended to call this method directly. This is a low level method that will be called by +@Transaction+.

Use this method to commit a transaction.

Example of low level operations using simple-jpa:

[source,groovy]
----
beginTransaction()
def em = getEntityManager()
... // perform works with em
em.close()
commitTransaction()
----

=== createEntityManager()

It is not recommended to call this method directly. This is a low level method that will be called by +@Transaction+.

Use this method to create a new EntityManager for current thread.

=== destroyEntityManager()

It is not recommended to call this method directly. This is a low level method that will be called by +@Transaction+.

Use this method to close all open EntityManager.

=== executeNamedQuery()

Use this method to execute JPA named query. This method will return a List that contains the result from named query
execution. The syntax of this method is:

[source,groovy]
----
def executeNamedQuery(String namedQuery, Map args, Map config = [:])
----

+namedQuery+ is the name of JPA named query that will be executed. +args+ is a +Map+ that stores query parameter values.
+config+ is an optional query configuration.

This is an example of JPA Named Query declaration:

[source,groovy]
----
@NamedQuery(name='Product.CalculateTotal', query='''
    SELECT SUM(i.qty) FROM items i WHERE
    i.product = :product AND (i.date <= :endDate)
'''
class Product {

}
----

To call the named query declared above, use the following code:

[source,groovy]
----
Product p = findProductByCode('P001')
def total = executeNamedQuery('Product.CalculateTotal',
    [product: p, endDate: LocalDate.now()])[0]
----

=== executeNativeQuery()

Use this method to execute native SQL. This is a low level query method (from JPA point of view) so it is better to use
+executeQuery()+ if possible. This method will return a +List+ that contains the result from SQL execution.

The syntax of this method is:

[source,groovy]
----
def executeNativeQuery (String sql, Map config = [:])
----

+sql+ is SQL string that will be executed. +config+ is an optional query configuration.

Example:

[source,groovy]
----
def mysqlDbUser = executeNativeQuery('SELECT user()')[0]
----

=== executeQuery()

Use this method to execute JP QL. This method will return a List that contains the result from JP QL execution.
The syntax of this method is:

[source,groovy]
----
def executeQuery (String jpql, Map config = [:], Map args = [:])
----

+jpql+ is JP QL string that will be executed. +config+ is an optional query configuration.

Example:

[source,groovy]
----
def allStudents = executeQuery('FROM Student')
----

=== getEntityManager()

It is not recommended to call this method directly. It is better to use simple-jpa methods rather than calling
EntityManager methods directly.

This method will return EntityManager for current thread.

Example:

[source,groovy]
----
createEntityManager()
def em = getEntityManager()
// do something with em
destroyEntityManager()
----

=== merge()

This is a shortcut for calling +merge()+ method of current EntityManager. Use this method to put a detached entity into
current EntityManager.

Example:

[source,groovy]
----
merge(student)
----

=== persist()

This is a shortcut for calling +persist()+ method of current EntityManager. Use this method to save a new entity into
database.

Example:

[source,groovy]
----
Student s = new Student()

// insert operation
persist(s)

// update operation
s.name = 'new'
----

=== remove()

This method will call +remove()+ method of current EntityManager. Before executing +remove()+, simple-jpa will try to
merge the entity if it is detached. Use this method to delete an entity from database.

Example:

[source,groovy]
----
findAllStudentByName('%Steve%').each {
  remove(it)
}
----

=== rollbackTransaction()

It is not recommended to call this method directly. This is a low level method that will be called by +@Transaction+.

Use this method to rollback a transaction and clear the EntityManager.

Example of low level operations using simple-jpa:

[source,groovy]
----
beginTransaction()
def em = getEntityManager()
... // perform works with em
rollbackTransaction()
em.close()
----

=== softDelete()

Use this method to set deleted attribute to +'Y'+. In simple-jpa, a soft deleted entity is an entity whose deleted
attribute is not equals to 'N'. To automatically add deleted attribute to an entity, use +@DomainClass+ annotation.

Example:

[source,groovy]
----
findAllStudentByName('%steve%').each {
    softDelete(it)
}
----

=== validate()

Use this method to validate an entity. The syntax for this method is:

[source,groovy]
----
def validate(entity, group = Default, viewModel = null)
----

+entity+ is the entity that will be validated (by using Java Validation API). +group+ is an optional interface that
marks one or more validation annotation as a group. By default, all declared validation annotations is part of
Default group.

This method will store validation result in model in the same MVCGroup or use viewModel value. All models in application
that uses simple-jpa will have the following injected attributes and methods:

[source,groovy]
----
ObservableMap errors = new ObservableMap(new ConcurrentHashMap())

boolean hasError() // return true if errors is not empty
----

Validation will not be performed if +model.hasError()+ is +true+. It is important to clear the previous errors before
reattempting validation.

If entity is not valid, this method will return +false+. Otherwise, it will return +true+. If this method return +false+,
it will store failed attributes and their error messages in +model.errors+.

This is an example of domain class with Java Validation API annotations:

[source,groovy]
----
@DomainClass @Entity @Canonical
class Student {
   @Size(min=2, max=50)
   String name

   @Min(0l) @Max(100l)
   Integer score
}
----

This is an example validation for the instance of domain class above:

[source,groovy]
----
Student s = new Student('a', 101)
model.errors.clear()
boolean result = validate(s)

println "Result is $result"
println "Messages: ${model.errors}"

// Output:
// Result is false
// Messages: [score:must be less than or equal to 100, name:size must be between 2 and 50]
----

To change the error messages returned by Java Validation API, edit the following file: +/griffon-app/i18n/ValidationMessages.properties+.

=== withTransaction()

This method will execute a closure as one transaction. The code inside the closure can call simple-jpa dynamic methods directly.

Example:

[source,groovy]
----
repository.withTransaction {
   Student student = findStudentByName("me");
   if (student) remove(student)
}
----