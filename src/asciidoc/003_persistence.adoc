== Persistence

By default, simple-jpa uses Hibernate JPA as persistence layer for your application.  You have to execute `create-simple-jpa`
 to setup persistence layer in your application.  This is the first script you will need to execute when you start a
 new project.

=== Setup

In order to setup your persistence layer, you need to call `create-simple-jpa` script.  This is usually performed once
 for every new project.  `create-simple-jpa` will create database user and schema for you if they don't exists.  Current version
  of simple-jpa only supports MySQL Server and Apache Derby Embedded setup.  If your database is not supported, you should
 configure your database manually.

If you use MySQL Server, you can execute `create-simple-jpa` like:

....
griffon create-simple-jpa -user=steven -password=12345 -database=sample
   -provider=hibernate -jdbc=mysql -rootPassword=secret
....

Because `hibernate` is default value for `-provider` and `mysql` is default value for `-jdbc`, you can ommit them:

....
griffon create-simple-jpa -user=steven -password=12345 -database=sample
   -rootPassword=secret
....

`create-simple-jpa` will check if `sample` database is exists or not.  If 'sample' database doesn't exists, it will be created.
  Because this operation requires root user and its password, you need to provide a value in `-rootPassword`.  This password
  won't be saved in your application.  `create-simple-jpa` also creates new database user called 'steven' with default password
  '12345' if it doesn't exists yet.  This user will have full privilleges on 'sample' database.

If you want to use Derby Embedded, you can execute `create-simple-jpa` like:

....
griffon create-simple-jpa -user=steven -password=12345 -database=C:/Users/steven/mydb
  -jdbc=derby-embedded -rootPassword=secret
....

When using `-jdbc=derby-embedded`, it is better to use absolute path for `-database` value.  Derby embedded database will
be created at the specified location.  The draw back of using absolute path is you must make sure database is copied
 to the proper location when you distribute your application.

Root password is not required when using Derby embedded.  If you didn't specify root password, `create-simple-jpa` will
create root user with password equals to user password (in this sample, it is '12345').

In addition to setup your database, `create-simple-jpa` also performs the following steps:

* Create `griffon-app/conf/metainf/persistence.xml` that contains information required to connect to database, such as
JDBC URL, database username and password.

* Create `griffon-app/conf/metainf/orm.xml` that register `AuditingEntityListener`.  This is required if you want to use
<<auditing>> feature.

* Create `griffon-app/i18n/ValidationMessages.properties`.  You can edit this file if you want to change <<validation-message>>.

* Add dependencies to JPA provider and JDBC driver in `griffon-app/conf/BuildConfig.groovy`.

If you want `create-simple-jpa` to perform the operations above without touching your database, use `-skipDatabase`
argument:

....
griffon create-simple-jpa -user=steven -password=12345 -database=sample -skipDatabase
....

You can instruct your JPA provider to recreate database objects (tables) based on current domain classes by executing
  `generate-schema` script:

....
griffon generate-schema -target=database -action=drop-and-create
....

Rather than directly executing in target database, `generate-schema` can also store the generated SQL statements in a file:

....
griffon generate-schema -target=script -action=create -createTarget=mydatabase.sql
....

The command above will create `mydatabase.sql` in current directory.  This file contains SQL statements to create
 tables required by your application.

=== JPA Configurations

By default, JPA provider will read persistence layer configurations stored in `persistence.xml`.  The following is a
sample `persistence.xml` created by `create-simple-jpa` script:

[source,xml]
.persistence.xml
----
<?xml version="1.0" encoding="UTF-8"?><persistence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/persistence" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" version="2.0">
  <persistence-unit name="default" transaction-type="RESOURCE_LOCAL">
    <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
    <class>domain.Product</class>
    <class>domain.LineItem</class>
    <class>domain.Invoice</class>
    <properties>
      <property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver"/>
      <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost/exercises"/>
      <property name="javax.persistence.jdbc.user" value="steven"/>
      <property name="javax.persistence.jdbc.password" value="12345"/>
      <property name="hibernate.connection.autocommit" value="false"/>
      <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL5Dialect"/>
      <property name="hibernate.connection.provider_class" value="org.hibernate.c3p0.internal.C3P0ConnectionProvider"/>
      <property name="javax.persistence.schema-generation.database.action" value="drop-and-create"/>
      <property name="jadira.usertype.autoRegisterUserTypes" value="true"/>
    </properties>
  </persistence-unit>
</persistence>
----

You can add new or edit existing JPA configurations inside `<properties/>`.  For example, setting
`javax.persistence.schema-generation.database.action` to `drop-and-create` makes your JPA provider to recreate
 database tables everytime application is launched.  You may want to disable this to make application startup faster.  If
 you disable auto schema generation, you can still use `generate-schema` to create database tables manually.

In addition to `persistence.xml`, simple-jpa also reads JPA configurations stored in `Config.groovy` and external
 properties file.  If more than one property are found, simple-jpa uses the value based on the following order:

1. Configuration passed as system properties (must start with `javax.persistence`) have the first priority.
2. Configuration stored in properties file have the first priority.
3. Configuration stored in `Config.groovy`.
4. Configuration stored in `persistence.xml`.

The following lines show a sample configurations added to `Config.groovy`:

[source,groovy]
.Config.groovy
----
griffon {
    simplejpa {
        entityManager {
            properties  {
                javax.persistence.jdbc.driver = 'com.mysql.jdbc.Driver'
                javax.persistence.jdbc.url = 'jdbc:mysql://localhost/mydatabase'
                javax.persistence.jdbc.user = 'scott'
                javax.persistence.jdbc.password = 'tiger'
                hibernate.connection.autocommit = 'false'
                hibernate.dialect = 'org.hibernate.dialect.MySQL5Dialect'
            }
        }
    }
}
----

The advantage of storing configurations in `Config.groovy` is you can have different JPA configurations per Griffon
 environments.  For example, the following configurations use different database for different environments:

[source,groovy]
.Config.groovy
----
griffon {
  simplejpa {
    entityManager {
      properties {
        environments {
          development {
            javax.persistence.jdbc.url = 'jdbc:mysql://localhost/exercises'
            javax.persistence.jdbc.user = 'steven'
            javax.persistence.jdbc.password = '12345'
          }
          test {
            javax.persistence.jdbc.url = 'jdbc:mysql://localhost/test'
            javax.persistence.jdbc.user = 'test'
            javax.persistence.jdbc.password = 'secret'
            javax.persistence.'schema-generation'.database.action = 'drop-and-create'
          }
        }
      }
    }
  }
}
----

If you run the application by using command like `run-app`, it will activate `development` environment.  In this case, JPA
uses database `jdbc:mysql://localhost/exercises`.  If you activate `test` environment (for example by running `test-app`),
JPA uses database `jdbc:mysql://localhost/test`.  It also recreate tables in that database.

To avoid storing sensitive information such as JDBC URL, username dan password in your source code, you
  can take advantage of Griffon feature to include properties file from `Config.groovy`.  For example, if you store JPA
  configuration to `hibernate.properties`, you can add the following line to `Config.groovy` to include your properties file:

[source,groovy]
.Config.groovy
----
griffon.config.locations = ['classpath:hibernate.properties']
----

You may want to configure your source code repository to make sure your properties file will never committed to public
server.

simple-jpa can also be configured to read JPA properties from external properties file.  You can define the location of this
properties file by adding the following line to `Config.groovy`:

[source,groovy]
----
griffon.simplejpa.entityManager.propertiesFile = 'C:/example/db.properties'
----

A sample `db.properties` will look like:

[source,groovy]
.C:/example/db.properties
----
javax.persistence.jdbc.url = 'jdbc:mysql://localhost/test'
javax.persistence.jdbc.user = 'test'
javax.persistence.jdbc.password = 'secret'
----

Configurations stored in this properties file will override existing configurations in `Config.groovy` and `persistence.xml`,
 but can be overriden by JVM system properties.  If you didn't change `griffon.simplejpa.entityManager.propertiesFile`,
 it defaults to `simplejpa.properties`.  This means you can always override JPA configuration for existing distribution by
 adding a new file called `simplejpa.properties` in the same location when you launched the application.

simple-jpa supports obfuscating configuration value.  For example, if you want to store obfuscated version of '12345', you
 need to execute the following command to retrieve its obsfuscated version:

....
griffon obfuscate -generate='12345'
....

Then, you can use the obfuscated version for any value in any location (such as `Config.groovy`, properties file or
system propeties).  For example, you can add the following line to `Config.groovy`:

[source,groovy]
----
griffon {
  simplejpa {
    entityManager {
      properties {
        javax.persistence.jdbc.password = 'obfuscated:YUqF9w6l5lpvNyH+1tnJBg=='
      }
    }
  }
}
----

WARNING: While obfuscation makes it harder for lay people to read your configuration file, it doesn't actually increase
  your security.  Anyone can easily display the original string by executing `griffon obfuscate -reverse`.   You should
  never publish obfuscated value if you don't want people to know the original value.

=== Domain Class

simple-jpa provides persistence methods to deal with persistent domain class (marked by `@Entity`).  To create such
  entity, you can use `create-domain-class` script, for example:

....
griffon create-domain-class Invoice LineItem
....

The command creates two new classes: `domain.Invoice` and `domain.LineItem`.  It also add these classes to `persistence.xml`.
  You can change the default base packages for domain classes by setting `griffon.simplejpa.domain.package` in `Config.groovy`.

You can also specify subpackage when executing `create-domain-class`, for example:

....
griffon create-domain-class sales.Invoice sales.LineItem inventory.Product
....

The command creates three new classes: `domain.sales.Invoice`, `domain.sales.LineItem` and `domain.inventory.Product`.

Persistent domain classes in simple-jpa is a normal JPA entities.  Just like when using JPA in Java, you can
decorate JPA entity with JPA annotations such as `@Entity`, `@OneToMany`, `@ManyToMany`, `@ManyToOne` and others.
See JPA documentation for more information about JPA annotations.  The following show examples of persistent domain
classes in simple-jpa:

[source,groovy]
.Invoice.groovy
----
package domain

// import statements are not shown.

@DomainClass @Entity @Canonical
class Invoice {

  @NotEmpty @Size(min=5, max=5)
  String number


  @NotNull @Type(type="org.jadira.usertype.dateandtime.joda.PersistentLocalDate")
  LocalDate date

  @ElementCollection @OrderColumn @NotEmpty
  List<LineItem> items = []

  void add(LineItem item) {
    items << item
  }

  BigDecimal total() {
    items.sum { it.total() }
  }

}
----

[source,groovy]
.LineItem.groovy
----
package domain

// import statements are not shown.

@Embeddable @Canonical
class LineItem {

  @NotNull @ManyToOne
  Product product

  @NotNull @Min(0l)
  BigDecimal price

  @NotNull @Min(1l)
  BigDecimal qty

  BigDecimal total() {
    price * qty
  }

}
----

[source,groovy]
.Product.groovy
----
package domain

// import statements are not shown.

@DomainClass @Entity @Canonical
class Product {

  @NotEmpty @Size(min=2, max=50)
  String name

  @NotNull @Min(value=1l)
  BigDecimal retailPrice

}
----

`@DomainClass` is special annotation provided by simple-jpa.  This annotation automatically adds the following property
 to the annotated class:

[source,groovy]
----
@Id @GeneratedValue(strategy=GenerationType.TABLE)   // <1>
Long id  // <2>

String deleted = 'N'  // <3>

Date createdDate   // <4>

String createdBy   // <4>

Date modifiedDate  // <4>

String modifiedBy  // <4>
----
<1> To change generation strategy, add desired strategy to `idGenerationStrategy` attribute.
<2> `@DomainClass(excludeId=true)` will not generate this property.
<3> `@DomainClass(excludeDeletedFlag=true)` will not generate this property.
<4> `@DomainClass(excludeAuditing=true)` will not generate these properties.

You aren't required to add `@DomainClass` to every persistent domain classes, but some features such as <<auditing>> will
not work without the properties generated by `@DomainClass`.  Of course, you can still code by hand the required properties in
every entities.

=== Persistence Methods

To make it possible for Griffon's  artifacts to manage domain classes, simple-jpa injects persistence methods to them.
By default, persistence methods are injected into controller, but you can change it by adding the following line to `Config.groovy`:

[source,groovy]
.Config.groovy
----
griffon.simplejpa.finders.injectInto = [ 'service', 'repository' ]
----

The configuration above will inject persistence methods to services and repositories.  Repository is a custom artifact type
provided by simple-jpa.  You can create a new repository by using `griffon create-repository`, for example:

....
griffon create-repository MyRepository
....

The script creates `MyRepository.groovy` in `griffon-app/repositories`.

To retrieve instance of repository, you can use code like:

[source,groovy]
----
def myRepository = SimpleJpaUtil.instance.repositoryManager.findRepository('MyRepository')
----

For a simple application, it is usually acceptable to inject persistence methods to controllers.  If you want a clear
 separation, you should inject persistence methods only to repositories.  You must add `@Transaction` annotation to
 the injected artifacts to enable <<transaction>>.  Class generated by `create-repository` already has `@Transaction`,
 but Griffon's controllers do not have `@Transaction` by default.

The following is list of persistence methods injected by simple-jpa:

* `persist(entity)`
+
Use this method to save new entity.  It is a shortcut for `entityManager.persist()`.

* `merge(entity)`
+
Use this method to add detached entity to current EntityManager.  It is a shortcut for `entityManager.merge()`.

* `remove(entity)`
+
Delete an entity.  It is a shortcut for `entityManager.remove()`.

* `softDelete(entity)`
+
Set `deleted` property of an entity into `'Y'`.

* `validate(object)`
+
See <<validation>> for more information.

* Finders
+
See <<finders>> for more information.

* `getEntityManager()`
+
Returns an `EntityManager` for current session.  This method can't be renamed.

* All public methods of `EntityManager`.
+
simple-jpa exposes all public methods of `EntityManager` to injected class.  This means you can directly call methods such
as `lock()`, `refresh()`, or `detach()` in injected class.  For more information about `EntityManager`, see JPA documentation.
These methods can't be renamed.

To avoid conflict with existing methods in injected class, simple-jpa can add prefix to persistence methods.  For example,
  you can add the following line to `Config.groovy`:

....
griffon.simplejpa.finders.prefix = 'jpa'
....

Now, every persistence methods that can be renamed will have 'jpa' prefix.  For example, you have to execute `jpaPersist()`
 rather than `persist()`.

The easiest way to learn simple-jpa persistence methods is by using `simple-jpa-console` script:

....
griffon simple-jpa-console
....

It will launch a Groovy console where you can write code snippet and see the result.

image::simple_jpa_console.PNG[]

The main advantage of Groovy console is you can edit existing code and execute it directly by selecting 'Script', 'Run' (Ctrl+R).
This is many times faster than relaunching application by using `griffon run-app`.  You will find Groovy console very useful
 in testing your code snippet or understanding the result of persistence methods.


