<?xml version="1.0" encoding="UTF-8"?>

<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" lang="en">
<info>
<title>Untitled</title>
<date>2014-07-30</date>
</info>
<appendix xml:id="_annotation">
<title>Annotation</title>
<simpara>These annotations are using Groovy AST transformation feature to change the content of a class dynamically on compile.</simpara>
<section xml:id="__conditionsupport">
<title>@ConditionSupport</title>
<simpara>Adding <literal>@ConditionSupport</literal> annotation to a Swing <literal>TableCellRenderer</literal> will make the renderer ready to use with
<literal>condition()</literal> node.</simpara>
<simpara>Example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@ConditionSupport
class MyCustomRenderer extends DefaultTableCellRenderer {
   ...
}</programlisting>
</section>
<section xml:id="__domainclass">
<title>@DomainClass</title>
<simpara>This annotation is supposed to be used on domain class, for example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@DomainClass
class Student {

}</programlisting>
<simpara><literal>@DomainClass</literal> annotation will add the following attribute to the annotated class:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@Id @GeneratedValue(strategy=GenerationType.TABLE)
Long id

String deleted = 'N'

Date createdDate

Date modifiedDate</programlisting>
<simpara><literal>@DomainClass</literal> will not add the attributes above if the annotated class is a subclass of another class which is
annotated by <literal>@DomainClass</literal> or <literal>@Entity</literal>.</simpara>
<simpara>To skip adding <literal>id</literal> attribute, set <literal>excludeId</literal> to <literal>true</literal>.</simpara>
<simpara>To skip adding <literal>deleted</literal> attribute, set <literal>excludeDeletedFlag</literal> to <literal>true</literal>.</simpara>
<simpara>To skip adding <literal>createdDate</literal> and <literal>modifiedDate</literal> attribute, set <literal>excludeAuditing</literal> to <literal>true</literal>. For example, the following
annotation will only add <literal>id</literal> to the annotated class:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@DomainClass(excludeDeletedFlag=true, excludeAuditing=true)
class Student {

}</programlisting>
<simpara>By default, the id generation strategy is <literal>GenerationType.TABLE</literal>. To change the default generation strategy, use
<literal>idGenerationStrategy</literal> member. For example, the following annotation will add an <literal>id</literal> attribute whose value is generated
by using database identity column (auto increment field):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@DomainClass(idGenerationStrategy=GenerationType.IDENTITY)
class Student {

}</programlisting>
<simpara>Warning: This annotation only add attributes to annotated class. Using this annotation on a class doesn&#8217;t mean that
simple-jpa will register it in <literal>persistence.xml</literal>. Even when a class is annotated with <literal>@DomainClass</literal>, if it is not
located in domain package, finders will not recognize it.</simpara>
</section>
<section xml:id="__transaction">
<title>@Transaction</title>
<simpara><literal>@Transaction</literal> annotation can be used to annotate a class, a closure field, or a method. It will cause the method or
closure to be wrapped in database transaction. Using <literal>@Transaction</literal> on a class will make all execution of methods or
closure fields in the class to be wrapped in database transaction. If there are both <literal>@Transaction</literal> annotation in a
method/closure field and its class, only annotation in method will be used.</simpara>
<simpara><literal>@Transaction</literal> can only be used in Griffon&#8217;s artifact (controllers or services) and domain classes (must be located
inside <literal>griffon.simplejpa.domain.package</literal>).</simpara>
<simpara><literal>@Transaction</literal> annotation value can be one of <literal>Policy.NORMAL</literal>, <literal>Policy.SKIP_PROPAGATION</literal>, and <literal>Policy.SKIP</literal>. The
default value is <literal>Policy.NORMAL</literal>.</simpara>
<simpara>A <literal>Policy.NORMAL</literal> transaction will join the previous transaction if it is called from another transaction. This will
enable transaction propagation. For example, the following code will not save any objects to database because
<literal>processA()</literal>, <literal>processB()</literal>, and <literal>processC()</literal> is part of one transaction and if any of them fails, all operations will
rollback:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@Transaction
class AController {

    def processC() {
    	throw new RuntimeException("Suddenly there is an error here!")
    }

    def processB() {
    	ADomainClass b = new ADomainClass()
        persist(b)
        processC()
    }

    def processA() {
    	ADomainClass a = new ADomainClass()
        persist(a)
        processB()
    }

}</programlisting>
<simpara>A <literal>Policy.SKIP_PROPAGATION</literal> transaction will always start a new transaction. It will not join previous transaction.
For example, the following code will result in <literal>a</literal> being persisted in database but <literal>b</literal> will be ignored:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@Transaction
class AController {

    @Transaction(Transaction.Policy.SKIP_PROPAGATION)
    def processB() {
    	ADomainClass b = new ADomainClass()
        persist(b)
        processC()
    }

    def processA() {
    	ADomainClass a = new ADomainClass()
        persist(a)
        processB()
    }

}</programlisting>
<simpara>A <literal>Policy.SKIP</literal> transaction mean there is no transaction at all (<literal>@Transaction</literal> will do nothing). It is recommended to
use this attribute to method or closure fields that don&#8217;t access database, as shown in the sample below:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@Transaction
class AController {

    @Transaction(Transaction.Policy.SKIP)
    def notRecommended() {
        ADomainClass a = new ADomainClass()
        persist(a)
        throw new RuntimeException("Suddenly fail here!")
        ADomainClass b = new ADomainClass()
        persist(b)
    }

    @Transaction(Transaction.Policy.SKIP)
    def recommended() {
        // Use it on method which doesn't require database access
        model.result = model.number1 + model.number2
    }
}</programlisting>
<simpara>In the example above, <literal>notRecommended()</literal> will persist <literal>a</literal> in the database but not <literal>b</literal> because an error was encountered
immediately after persisting <literal>a</literal>. This is not recommended because it will leave database in inconsistent state.</simpara>
</section>
</appendix>
</article>